name: Release Desktop

on:
  push:
    branches:
      - main
    paths:
      - "apps/desktop/**"
      - ".github/workflows/release-desktop.yml"
  workflow_dispatch:
    inputs:
      environment:
        description: "Release environment (prod promotes the most recent dev tag)"
        type: choice
        required: true
        default: prod
        options:
          - prod
          - dev
      version:
        description: "Semver version to promote (prod only, defaults to latest dev tag)"
        required: false
        type: string

jobs:
  metadata:
    name: Determine release metadata
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      version: ${{ steps.meta.outputs.version }}
      tag_name: ${{ steps.meta.outputs.tag_name }}
      commit_sha: ${{ steps.meta.outputs.commit_sha }}
      release_env: ${{ steps.meta.outputs.release_env }}
      release_suffix: ${{ steps.meta.outputs.release_suffix }}
      release_flavor: ${{ steps.meta.outputs.release_flavor }}
      channel_release_tag: ${{ steps.meta.outputs.channel_release_tag }}
      version_path: ${{ steps.meta.outputs.version_path }}
      dev_tag_name: ${{ steps.meta.outputs.dev_tag_name }}
    steps:
      - name: Checkout source
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute release metadata
        id: meta
        env:
          EVENT_NAME: ${{ github.event_name }}
          INPUT_ENVIRONMENT: ${{ github.event.inputs.environment || '' }}
          INPUT_VERSION: ${{ github.event.inputs.version || '' }}
        run: |
          set -euo pipefail
          git fetch --tags --force

          if [[ "${EVENT_NAME}" == "push" ]]; then
            RELEASE_ENV="dev"
          else
            case "${INPUT_ENVIRONMENT:-prod}" in
              dev|prod)
                RELEASE_ENV="${INPUT_ENVIRONMENT:-prod}"
                ;;
              *)
                echo "Unsupported environment '${INPUT_ENVIRONMENT}'" >&2
                exit 1
                ;;
            esac
          fi

          SEMVER_REGEX='^[0-9]+\.[0-9]+\.[0-9]+$'
          INPUT_VERSION="${INPUT_VERSION:-}"

          LAST_DEV_TAG="$(git tag --list 'desktop-dev-v*' --sort=-v:refname | head -n 1)"

          if [[ "${RELEASE_ENV}" == "dev" ]]; then
            if [[ -n "${INPUT_VERSION}" ]]; then
              echo "Ignoring manual version '${INPUT_VERSION}' for dev release (automatic patch bump used)." >&2
            fi

            if [[ -z "${LAST_DEV_TAG}" ]]; then
              VERSION_BASE="0.0.0"
            else
              VERSION_BASE="${LAST_DEV_TAG#desktop-dev-v}"
            fi

            if [[ ! "${VERSION_BASE}" =~ ${SEMVER_REGEX} ]]; then
              echo "Last dev tag (${LAST_DEV_TAG:-none}) is not in x.y.z format." >&2
              exit 1
            fi

            IFS='.' read -r MAJOR MINOR PATCH <<< "${VERSION_BASE}"
            PATCH=$((PATCH + 1))
            VERSION="${MAJOR}.${MINOR}.${PATCH}"
            TAG_NAME="desktop-dev-v${VERSION}"
            COMMIT_SHA="${GITHUB_SHA}"
            DEV_TAG_NAME="${TAG_NAME}"
          else
            if [[ -n "${INPUT_VERSION}" ]]; then
              TARGET_VERSION="${INPUT_VERSION}"
              if [[ ! "${TARGET_VERSION}" =~ ${SEMVER_REGEX} ]]; then
                echo "Provided version '${TARGET_VERSION}' is not in x.y.z format." >&2
                exit 1
              fi
              TARGET_DEV_TAG="desktop-dev-v${TARGET_VERSION}"
              if ! git rev-parse -q --verify "refs/tags/${TARGET_DEV_TAG}" >/dev/null; then
                echo "Dev tag ${TARGET_DEV_TAG} not found for promotion." >&2
                exit 1
              fi
            else
              if [[ -z "${LAST_DEV_TAG}" ]]; then
                echo "No dev tag found to promote to prod." >&2
                exit 1
              fi
              TARGET_DEV_TAG="${LAST_DEV_TAG}"
              TARGET_VERSION="${TARGET_DEV_TAG#desktop-dev-v}"
              if [[ ! "${TARGET_VERSION}" =~ ${SEMVER_REGEX} ]]; then
                echo "Dev tag ${TARGET_DEV_TAG} is not in x.y.z format." >&2
                exit 1
              fi
            fi

            VERSION="${TARGET_VERSION}"
            TAG_NAME="desktop-v${VERSION}"
            COMMIT_SHA="$(git rev-parse "${TARGET_DEV_TAG}^{commit}")"
            DEV_TAG_NAME="${TARGET_DEV_TAG}"
          fi

          if git rev-parse -q --verify "refs/tags/${TAG_NAME}" >/dev/null; then
            echo "Tag ${TAG_NAME} already exists. Aborting." >&2
            exit 1
          fi

          VERSION_PATH="desktop/${RELEASE_ENV}/${VERSION}"
          if [[ "${RELEASE_ENV}" == "dev" ]]; then
            CHANNEL_RELEASE_TAG="desktop-dev"
            RELEASE_FLAVOR="dev"
            RELEASE_SUFFIX="-dev"
          else
            CHANNEL_RELEASE_TAG="desktop-prod"
            RELEASE_FLAVOR="prod"
            RELEASE_SUFFIX=""
          fi

          {
            echo "release_env=${RELEASE_ENV}"
            echo "release_suffix=${RELEASE_SUFFIX}"
            echo "version=${VERSION}"
            echo "tag_name=${TAG_NAME}"
            echo "commit_sha=${COMMIT_SHA}"
            echo "dev_tag_name=${DEV_TAG_NAME}"
            echo "version_path=${VERSION_PATH}"
            echo "channel_release_tag=${CHANNEL_RELEASE_TAG}"
            echo "release_flavor=${RELEASE_FLAVOR}"
          } >> "$GITHUB_OUTPUT"

      - name: Create release tag
        uses: actions/github-script@v7
        env:
          TAG_NAME: ${{ steps.meta.outputs.tag_name }}
          TARGET_SHA: ${{ steps.meta.outputs.commit_sha }}
        with:
          script: |
            const tagName = process.env.TAG_NAME;
            const targetSha = process.env.TARGET_SHA;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            core.info(`Creating tag ${tagName} at ${targetSha}`);

            await github.rest.git.createRef({
              owner,
              repo,
              ref: `refs/tags/${tagName}`,
              sha: targetSha,
            });

  build:
    name: Build ${{ matrix.label }}
    needs: metadata
    runs-on: ${{ matrix.os }}
    timeout-minutes: 120
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - label: macOS (universal)
            os: macos-14
            args: "--target universal-apple-darwin"
            rust_targets: "aarch64-apple-darwin,x86_64-apple-darwin"
            tauri_platform: macos
            node_platform: darwin
            artifact_name: desktop-macos
          - label: Linux
            os: ubuntu-22.04
            args: ""
            rust_targets: ""
            tauri_platform: linux
            node_platform: linux
            artifact_name: desktop-linux
          - label: Windows
            os: windows-latest
            args: ""
            rust_targets: ""
            tauri_platform: windows
            node_platform: win32
            artifact_name: desktop-windows
    env:
      RELEASE_VERSION: ${{ needs.metadata.outputs.version }}
      RELEASE_ENV: ${{ needs.metadata.outputs.release_env }}
      RELEASE_SUFFIX: ${{ needs.metadata.outputs.release_suffix }}
      RELEASE_FLAVOR: ${{ needs.metadata.outputs.release_flavor }}
      FLAVOR: ${{ needs.metadata.outputs.release_flavor }}
      VOQUILL_BUILD_FLAVOR: ${{ needs.metadata.outputs.release_flavor }}
      VOQUILL_DESKTOP_FLAVOR: ${{ needs.metadata.outputs.release_flavor }}
      TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
      TAURI_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_PRIVATE_KEY_PASSWORD }}
      TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
      TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_PRIVATE_KEY_PASSWORD }}
      TAURI_UPDATER_PUBLIC_KEY: ${{ secrets.TAURI_UPDATER_PUBLIC_KEY }}
      APPLE_API_KEY_BASE64: ${{ secrets.APPLE_API_KEY_BASE64 }}
      APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
      APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.metadata.outputs.commit_sha }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc
          cache: npm
          cache-dependency-path: package-lock.json

      - name: Sync Tauri release configuration
        run: node scripts/ci/set-tauri-release-config.mjs

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.rust_targets }}

      - name: Cache cargo
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            apps/desktop/src-tauri -> target

      - name: Install system dependencies (Linux)
        if: matrix.os == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential libwebkit2gtk-4.1-dev libwebkit2gtk-4.0-dev libappindicator3-dev librsvg2-dev libasound2-dev libxdo-dev patchelf

      - name: Install dependencies
        run: npm ci

      - name: Import Apple signing certificate
        if: matrix.os == 'macos-14'
        id: import-macos-cert
        uses: apple-actions/import-codesign-certs@v2
        with:
          create-keychain: true
          keychain: build
          keychain-password: ${{ secrets.KEYCHAIN_PASSWORD }}
          keychain-timeout: 3600
          set-default-keychain: true
          p12-file-base64: ${{ secrets.APPLE_CERTIFICATE }}
          p12-password: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}

      - name: Allow codesign access to private keys (CI keychain)
        if: matrix.os == 'macos-14'
        run: |
          security set-key-partition-list -S apple-tool:,apple: -s -k "${{ secrets.KEYCHAIN_PASSWORD }}" build.keychain-db

      - name: Assert Developer ID Application identity is present
        if: matrix.os == 'macos-14'
        run: |
          set -euo pipefail
          out="$(security find-identity -v -p codesigning)"
          echo "$out"
          echo "$out" | grep -q "Developer ID Application" || {
            echo "No 'Developer ID Application' identity found. Import a .p12 exported with its private key." >&2
            exit 1
          }

      - name: Prepare Apple notary API key
        if: matrix.os == 'macos-14'
        run: |
          set -euo pipefail
          echo "$APPLE_API_KEY_BASE64" | base64 -d > AuthKey.p8
          ls -l AuthKey.p8
        shell: bash

      - name: Verify Apple signing identity
        if: matrix.os == 'macos-14'
        run: |
          set -euo pipefail
          keychain_path="${{ steps.import-macos-cert.outputs['keychain-path'] }}"
          if [[ -z "${keychain_path}" ]]; then
            keychain_path="${HOME}/Library/Keychains/build.keychain-db"
            echo "apple-actions/import-codesign-certs did not report a keychain path; falling back to ${keychain_path}." >&2
          fi
          output="$(security find-identity -v -p codesigning "${keychain_path}" || true)"
          printf '%s\n' "$output"
          summary_count="$(printf '%s\n' "$output" | awk '/valid identities found$/ { print $1; exit }')"
          if [[ -z "${summary_count}" || ! "${summary_count}" =~ ^[0-9]+$ ]]; then
            summary_count="$(printf '%s\n' "$output" | awk '/^[[:space:]]*[0-9]+\)/ { count++ } END { print count+0 }')"
          fi
          if [[ "${summary_count:-0}" -eq 0 ]]; then
            echo "No valid code signing identities were imported into ${keychain_path}." >&2
            echo "Ensure APPLE_CERTIFICATE contains a base64-encoded .p12 export that includes the private key." >&2
            exit 1
          fi

      - name: Turbo build desktop workspace
        env:
          MACOSX_DEPLOYMENT_TARGET: "13.3"
          CMAKE_OSX_DEPLOYMENT_TARGET: "13.3"
          TAURI_PLATFORM: ${{ matrix.tauri_platform }}
          VOQUILL_DESKTOP_PLATFORM: ${{ matrix.node_platform }}
        run: npm run build -- --filter=desktop...

      - name: Build and publish
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_PLATFORM: ${{ matrix.tauri_platform }}
          VOQUILL_DESKTOP_PLATFORM: ${{ matrix.node_platform }}
          MACOSX_DEPLOYMENT_TARGET: "13.3"
          CMAKE_OSX_DEPLOYMENT_TARGET: "13.3"
          APPLE_TEAM_ID: ${{ env.APPLE_TEAM_ID }}
          APPLE_SIGNING_IDENTITY: ${{ env.APPLE_SIGNING_IDENTITY }}
          APPLE_API_KEY: ${{ env.APPLE_API_KEY_ID }}
          APPLE_API_KEY_ID: ${{ env.APPLE_API_KEY_ID }}
          APPLE_API_KEY_PATH: ${{ github.workspace }}/AuthKey.p8
          APPLE_API_ISSUER: ${{ env.APPLE_API_ISSUER }}
          TAURI_LOG_LEVEL: ${{ env.TAURI_LOG_LEVEL }}
          RUST_LOG: ${{ env.RUST_LOG }}
        with:
          projectPath: apps/desktop
          tauriScript: npm run --workspace desktop tauri
          args: ${{ matrix.args }}
          tagName: ${{ needs.metadata.outputs.tag_name }}
          releaseName: desktop${{ needs.metadata.outputs.release_suffix }} v${{ needs.metadata.outputs.version }}
          releaseBody: Automated ${{ needs.metadata.outputs.release_env }} channel build for version ${{ needs.metadata.outputs.version }}.
          releaseDraft: false
          prerelease: ${{ needs.metadata.outputs.release_env != 'prod' }}
          includeUpdaterJson: true

  update-channel:
    name: Update channel release asset
    needs: [metadata, build]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      CHANNEL_TAG: ${{ needs.metadata.outputs.channel_release_tag }}
      GH_REPO: ${{ github.repository }}
      RELEASE_TAG: ${{ needs.metadata.outputs.tag_name }}
    steps:
      - name: Download latest.json from release
        run: |
          set -euo pipefail
          mkdir -p dist
          gh release download "$RELEASE_TAG" --pattern "latest.json" --dir dist --clobber
          if [[ ! -s dist/latest.json ]]; then
            echo "latest.json was not downloaded from release ${RELEASE_TAG}" >&2
            ls -la dist
            exit 1
          fi
      - name: Validate downloaded latest.json
        run: |
          set -euo pipefail
          version="$(jq -r '.version // empty' dist/latest.json)"
          expected="${{ needs.metadata.outputs.version }}"
          if [[ -z "${version}" ]]; then
            echo "latest.json is missing a 'version' field." >&2
            exit 1
          fi
          if [[ "${version}" != "${expected}" ]]; then
            echo "latest.json version '${version}' does not match expected '${expected}'." >&2
            exit 1
          fi
      - name: Upload to channel
        run: |
          set -euo pipefail
          gh release upload "$CHANNEL_TAG" dist/latest.json --clobber
