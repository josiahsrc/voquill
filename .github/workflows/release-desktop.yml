name: Release Desktop

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: "Release environment (prod promotes the most recent dev tag)"
        type: choice
        required: true
        default: prod
        options:
          - prod
          - dev
      version:
        description: "Semver version to promote (prod only, defaults to latest dev tag)"
        required: false
        type: string

jobs:
  metadata:
    name: Determine release metadata
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      version: ${{ steps.meta.outputs.version }}
      tag_name: ${{ steps.meta.outputs.tag_name }}
      commit_sha: ${{ steps.meta.outputs.commit_sha }}
      release_env: ${{ steps.meta.outputs.release_env }}
      release_flavor: ${{ steps.meta.outputs.release_flavor }}
      channel_release_tag: ${{ steps.meta.outputs.channel_release_tag }}
      version_path: ${{ steps.meta.outputs.version_path }}
      dev_tag_name: ${{ steps.meta.outputs.dev_tag_name }}
    steps:
      - name: Checkout source
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute release metadata
        id: meta
        env:
          EVENT_NAME: ${{ github.event_name }}
          INPUT_ENVIRONMENT: ${{ github.event.inputs.environment || '' }}
          INPUT_VERSION: ${{ github.event.inputs.version || '' }}
        run: |
          set -euo pipefail
          git fetch --tags --force

          if [[ "${EVENT_NAME}" == "push" ]]; then
            RELEASE_ENV="dev"
          else
            case "${INPUT_ENVIRONMENT:-prod}" in
              dev|prod)
                RELEASE_ENV="${INPUT_ENVIRONMENT:-prod}"
                ;;
              *)
                echo "Unsupported environment '${INPUT_ENVIRONMENT}'" >&2
                exit 1
                ;;
            esac
          fi

          SEMVER_REGEX='^[0-9]+\.[0-9]+\.[0-9]+$'
          INPUT_VERSION="${INPUT_VERSION:-}"

          LAST_DEV_TAG="$(git tag --list 'desktop-dev-v*' --sort=-v:refname | head -n 1)"

          if [[ "${RELEASE_ENV}" == "dev" ]]; then
            if [[ -n "${INPUT_VERSION}" ]]; then
              echo "Ignoring manual version '${INPUT_VERSION}' for dev release (automatic patch bump used)." >&2
            fi

            if [[ -z "${LAST_DEV_TAG}" ]]; then
              VERSION_BASE="0.0.0"
            else
              VERSION_BASE="${LAST_DEV_TAG#desktop-dev-v}"
            fi

            if [[ ! "${VERSION_BASE}" =~ ${SEMVER_REGEX} ]]; then
              echo "Last dev tag (${LAST_DEV_TAG:-none}) is not in x.y.z format." >&2
              exit 1
            fi

            IFS='.' read -r MAJOR MINOR PATCH <<< "${VERSION_BASE}"
            PATCH=$((PATCH + 1))
            VERSION="${MAJOR}.${MINOR}.${PATCH}"
            TAG_NAME="desktop-dev-v${VERSION}"
            COMMIT_SHA="${GITHUB_SHA}"
            DEV_TAG_NAME="${TAG_NAME}"
          else
            if [[ -n "${INPUT_VERSION}" ]]; then
              TARGET_VERSION="${INPUT_VERSION}"
              if [[ ! "${TARGET_VERSION}" =~ ${SEMVER_REGEX} ]]; then
                echo "Provided version '${TARGET_VERSION}' is not in x.y.z format." >&2
                exit 1
              fi
              TARGET_DEV_TAG="desktop-dev-v${TARGET_VERSION}"
              if ! git rev-parse -q --verify "refs/tags/${TARGET_DEV_TAG}" >/dev/null; then
                echo "Dev tag ${TARGET_DEV_TAG} not found for promotion." >&2
                exit 1
              fi
            else
              if [[ -z "${LAST_DEV_TAG}" ]]; then
                echo "No dev tag found to promote to prod." >&2
                exit 1
              fi
              TARGET_DEV_TAG="${LAST_DEV_TAG}"
              TARGET_VERSION="${TARGET_DEV_TAG#desktop-dev-v}"
              if [[ ! "${TARGET_VERSION}" =~ ${SEMVER_REGEX} ]]; then
                echo "Dev tag ${TARGET_DEV_TAG} is not in x.y.z format." >&2
                exit 1
              fi
            fi

            VERSION="${TARGET_VERSION}"
            TAG_NAME="desktop-v${VERSION}"
            COMMIT_SHA="$(git rev-parse "${TARGET_DEV_TAG}^{commit}")"
            DEV_TAG_NAME="${TARGET_DEV_TAG}"
          fi

          if git rev-parse -q --verify "refs/tags/${TAG_NAME}" >/dev/null; then
            echo "Tag ${TAG_NAME} already exists. Aborting." >&2
            exit 1
          fi

          VERSION_PATH="desktop/${RELEASE_ENV}/${VERSION}"
          if [[ "${RELEASE_ENV}" == "dev" ]]; then
            CHANNEL_RELEASE_TAG="desktop-dev"
            RELEASE_FLAVOR="dev"
          else
            CHANNEL_RELEASE_TAG="desktop-prod"
            RELEASE_FLAVOR="prod"
          fi

          {
            echo "release_env=${RELEASE_ENV}"
            echo "version=${VERSION}"
            echo "tag_name=${TAG_NAME}"
            echo "commit_sha=${COMMIT_SHA}"
            echo "dev_tag_name=${DEV_TAG_NAME}"
            echo "version_path=${VERSION_PATH}"
            echo "channel_release_tag=${CHANNEL_RELEASE_TAG}"
            echo "release_flavor=${RELEASE_FLAVOR}"
          } >> "$GITHUB_OUTPUT"

      - name: Create release tag
        uses: actions/github-script@v7
        env:
          TAG_NAME: ${{ steps.meta.outputs.tag_name }}
          TARGET_SHA: ${{ steps.meta.outputs.commit_sha }}
        with:
          script: |
            const tagName = process.env.TAG_NAME;
            const targetSha = process.env.TARGET_SHA;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            core.info(`Creating tag ${tagName} at ${targetSha}`);

            await github.rest.git.createRef({
              owner,
              repo,
              ref: `refs/tags/${tagName}`,
              sha: targetSha,
            });

  build:
    name: Build ${{ matrix.label }}
    needs: metadata
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - label: macOS (universal)
            os: macos-14
            args: "--target universal-apple-darwin"
            rust_targets: "aarch64-apple-darwin,x86_64-apple-darwin"
            tauri_platform: macos
            node_platform: darwin
            artifact_name: desktop-macos
          - label: Linux
            os: ubuntu-22.04
            args: ""
            rust_targets: ""
            tauri_platform: linux
            node_platform: linux
            artifact_name: desktop-linux
          - label: Windows
            os: windows-latest
            args: ""
            rust_targets: ""
            tauri_platform: windows
            node_platform: win32
            artifact_name: desktop-windows
    env:
      RELEASE_VERSION: ${{ needs.metadata.outputs.version }}
      RELEASE_ENV: ${{ needs.metadata.outputs.release_env }}
      RELEASE_FLAVOR: ${{ needs.metadata.outputs.release_flavor }}
      FLAVOR: ${{ needs.metadata.outputs.release_flavor }}
      VOQUILL_BUILD_FLAVOR: ${{ needs.metadata.outputs.release_flavor }}
      VOQUILL_DESKTOP_FLAVOR: ${{ needs.metadata.outputs.release_flavor }}
      TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
      TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_PRIVATE_KEY_PASSWORD }}
      TAURI_UPDATER_PUBLIC_KEY: ${{ secrets.TAURI_UPDATER_PUBLIC_KEY }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.metadata.outputs.commit_sha }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 24.10.0
          cache: npm
          cache-dependency-path: package-lock.json

      - name: Sync Tauri release configuration
        run: node scripts/ci/set-tauri-release-config.mjs

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.rust_targets }}

      - name: Cache cargo
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            apps/desktop/src-tauri -> target

      - name: Install system dependencies (Linux)
        if: matrix.os == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential libwebkit2gtk-4.1-dev libwebkit2gtk-4.0-dev libappindicator3-dev librsvg2-dev libasound2-dev libxdo-dev patchelf

      - name: Install dependencies
        run: npm ci

      - name: Turbo build desktop workspace
        env:
          MACOSX_DEPLOYMENT_TARGET: "13.3"
          CMAKE_OSX_DEPLOYMENT_TARGET: "13.3"
          TAURI_PLATFORM: ${{ matrix.tauri_platform }}
          VOQUILL_DESKTOP_PLATFORM: ${{ matrix.node_platform }}
        run: npm run build -- --filter=desktop...

      - name: Build desktop bundle
        shell: bash
        env:
          MACOSX_DEPLOYMENT_TARGET: "13.3"
          CMAKE_OSX_DEPLOYMENT_TARGET: "13.3"
          TAURI_PLATFORM: ${{ matrix.tauri_platform }}
          VOQUILL_DESKTOP_PLATFORM: ${{ matrix.node_platform }}
          TAURI_BUILD_ARGS: ${{ matrix.args }}
        run: |
          if [[ -n "${TAURI_BUILD_ARGS}" ]]; then
            npm run --workspace desktop tauri build -- ${TAURI_BUILD_ARGS}
          else
            npm run --workspace desktop tauri build
          fi

      - name: Collect build artifacts
        run: node scripts/ci/collect-tauri-artifacts.mjs
        env:
          ARTIFACT_OUTPUT_DIR: release-artifacts
          TAURI_ARTIFACT_LABEL: ${{ matrix.artifact_name }}

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: release-artifacts
          if-no-files-found: error

  publish:
    name: Publish release assets
    needs:
      - metadata
      - build
    runs-on: ubuntu-latest
    env:
      RELEASE_ENV: ${{ needs.metadata.outputs.release_env }}
      RELEASE_VERSION: ${{ needs.metadata.outputs.version }}
      RELEASE_TAG_NAME: ${{ needs.metadata.outputs.tag_name }}
      CHANNEL_RELEASE_TAG: ${{ needs.metadata.outputs.channel_release_tag }}
      RELEASE_FLAVOR: ${{ needs.metadata.outputs.release_flavor }}
      FLAVOR: ${{ needs.metadata.outputs.release_flavor }}
      VOQUILL_BUILD_FLAVOR: ${{ needs.metadata.outputs.release_flavor }}
      VOQUILL_DESKTOP_FLAVOR: ${{ needs.metadata.outputs.release_flavor }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 24.10.0

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare release payload
        run: node scripts/ci/prepare-tauri-release.mjs
        env:
          ARTIFACTS_DIR: artifacts
          OUTPUT_DIR: publish
          RELEASE_ENV: ${{ needs.metadata.outputs.release_env }}
          RELEASE_VERSION: ${{ needs.metadata.outputs.version }}
          RELEASE_TAG_NAME: ${{ needs.metadata.outputs.tag_name }}
          CHANNEL_RELEASE_TAG: ${{ needs.metadata.outputs.channel_release_tag }}

      - name: Create or update version release
        id: version_release
        uses: actions/github-script@v7
        env:
          RELEASE_TAG: ${{ needs.metadata.outputs.tag_name }}
          RELEASE_ENV: ${{ needs.metadata.outputs.release_env }}
          RELEASE_VERSION: ${{ needs.metadata.outputs.version }}
        with:
          script: |
            const releaseTag = process.env.RELEASE_TAG;
            const releaseEnv = process.env.RELEASE_ENV;
            const releaseVersion = process.env.RELEASE_VERSION;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const releaseName =
              releaseEnv === "dev"
                ? `Desktop Dev ${releaseVersion}`
                : `Desktop ${releaseVersion}`;
            const body = `Automated ${releaseEnv === "dev" ? "dev" : "prod"} channel build for version ${releaseVersion}.`;

            async function upsertRelease() {
              try {
                const existing = await github.rest.repos.getReleaseByTag({
                  owner,
                  repo,
                  tag: releaseTag,
                });
                core.info(`Updating release ${existing.data.id} for tag ${releaseTag}.`);
                const updated = await github.rest.repos.updateRelease({
                  owner,
                  repo,
                  release_id: existing.data.id,
                  tag_name: releaseTag,
                  name: releaseName,
                  body,
                  draft: false,
                  prerelease: releaseEnv !== "prod",
                });
                return updated.data;
              } catch (error) {
                if (error.status === 404) {
                  core.info(`Creating release for tag ${releaseTag}.`);
                  const created = await github.rest.repos.createRelease({
                    owner,
                    repo,
                    tag_name: releaseTag,
                    name: releaseName,
                    body,
                    draft: false,
                    prerelease: releaseEnv !== "prod",
                  });
                  return created.data;
                }
                throw error;
              }
            }

            const release = await upsertRelease();
            core.setOutput("release_id", String(release.id));
            core.info(`Version release ready at ${release.html_url}.`);

      - name: Upload version binaries
        if: steps.version_release.outputs.release_id != ''
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ steps.version_release.outputs.release_id }}
          ASSET_ROOT: publish/binaries
          NAME_STRATEGY: flatten
          ASSET_PREFIX: ""
        with:
          script: |
            const fs = require("node:fs");
            const path = require("node:path");

            const releaseId = Number(process.env.RELEASE_ID);
            const assetRoot = process.env.ASSET_ROOT;
            const nameStrategy = process.env.NAME_STRATEGY || "flatten";
            const assetPrefix = process.env.ASSET_PREFIX || "";
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            if (!assetRoot || !fs.existsSync(assetRoot)) {
              core.info(`Asset root '${assetRoot}' not found; skipping upload.`);
              return;
            }

            async function collectFiles(dir) {
              const entries = await fs.promises.readdir(dir, { withFileTypes: true });
              const files = [];
              for (const entry of entries) {
                const fullPath = path.join(dir, entry.name);
                if (entry.isDirectory()) {
                  files.push(...await collectFiles(fullPath));
                } else if (entry.isFile()) {
                  files.push(fullPath);
                }
              }
              return files;
            }

            function contentTypeFor(name) {
              const lower = name.toLowerCase();
              if (lower.endsWith(".json")) return "application/json";
              if (lower.endsWith(".zip")) return "application/zip";
              if (lower.endsWith(".tar.gz") || lower.endsWith(".tgz")) return "application/gzip";
              if (lower.endsWith(".dmg")) return "application/x-apple-diskimage";
              if (lower.endsWith(".msi")) return "application/x-msi";
              if (lower.endsWith(".exe")) return "application/vnd.microsoft.portable-executable";
              return "application/octet-stream";
            }

            function buildAssetName(filePath) {
              const relative = path.relative(assetRoot, filePath);
              if (nameStrategy === "basename") {
                return `${assetPrefix}${path.basename(filePath)}`;
              }
              const flattened = relative
                .split(path.sep)
                .filter(Boolean)
                .join("-");
              const base = flattened || path.basename(filePath);
              return `${assetPrefix}${base}`;
            }

            const files = await collectFiles(assetRoot);
            if (files.length === 0) {
              core.info(`No files found under '${assetRoot}'.`);
              return;
            }

            const existingAssets = await github.paginate(
              github.rest.repos.listReleaseAssets,
              {
                owner,
                repo,
                release_id: releaseId,
                per_page: 100,
              },
            );
            const existingByName = new Map(
              existingAssets.map((asset) => [asset.name, asset.id]),
            );

            for (const filePath of files) {
              const assetName = buildAssetName(filePath);
              const stat = await fs.promises.stat(filePath);

              const existingId = existingByName.get(assetName);
              if (existingId) {
                core.info(`Deleting existing asset '${assetName}' (id ${existingId}).`);
                await github.rest.repos.deleteReleaseAsset({
                  owner,
                  repo,
                  asset_id: existingId,
                });
                existingByName.delete(assetName);
              }

              core.info(`Uploading '${assetName}' from ${filePath}.`);
              await github.rest.repos.uploadReleaseAsset({
                owner,
                repo,
                release_id: releaseId,
                name: assetName,
                data: fs.createReadStream(filePath),
                headers: {
                  "content-type": contentTypeFor(assetName),
                  "content-length": stat.size,
                },
              });
            }

            core.info(`Uploaded ${files.length} assets to release ${releaseId}.`);

      - name: Upload version metadata
        if: steps.version_release.outputs.release_id != ''
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ steps.version_release.outputs.release_id }}
          ASSET_ROOT: publish/version
          NAME_STRATEGY: basename
          ASSET_PREFIX: ""
        with:
          script: |
            const fs = require("node:fs");
            const path = require("node:path");

            const releaseId = Number(process.env.RELEASE_ID);
            const assetRoot = process.env.ASSET_ROOT;
            const nameStrategy = process.env.NAME_STRATEGY || "basename";
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            if (!assetRoot || !fs.existsSync(assetRoot)) {
              core.info(`Asset root '${assetRoot}' not found; skipping upload.`);
              return;
            }

            async function collectFiles(dir) {
              const entries = await fs.promises.readdir(dir, { withFileTypes: true });
              const files = [];
              for (const entry of entries) {
                const fullPath = path.join(dir, entry.name);
                if (entry.isDirectory()) {
                  files.push(...await collectFiles(fullPath));
                } else if (entry.isFile()) {
                  files.push(fullPath);
                }
              }
              return files;
            }

            function contentTypeFor(name) {
              const lower = name.toLowerCase();
              if (lower.endsWith(".json")) return "application/json";
              return "application/octet-stream";
            }

            function buildAssetName(filePath) {
              if (nameStrategy === "basename") {
                return path.basename(filePath);
              }
              const relative = path.relative(assetRoot, filePath);
              return relative.split(path.sep).join("-");
            }

            const files = await collectFiles(assetRoot);
            if (files.length === 0) {
              core.info(`No files found under '${assetRoot}'.`);
              return;
            }

            const existingAssets = await github.paginate(
              github.rest.repos.listReleaseAssets,
              {
                owner,
                repo,
                release_id: releaseId,
                per_page: 100,
              },
            );
            const existingByName = new Map(
              existingAssets.map((asset) => [asset.name, asset.id]),
            );

            for (const filePath of files) {
              const assetName = buildAssetName(filePath);
              const stat = await fs.promises.stat(filePath);

              const existingId = existingByName.get(assetName);
              if (existingId) {
                core.info(`Deleting existing asset '${assetName}' (id ${existingId}).`);
                await github.rest.repos.deleteReleaseAsset({
                  owner,
                  repo,
                  asset_id: existingId,
                });
                existingByName.delete(assetName);
              }

              core.info(`Uploading '${assetName}' from ${filePath}.`);
              await github.rest.repos.uploadReleaseAsset({
                owner,
                repo,
                release_id: releaseId,
                name: assetName,
                data: fs.createReadStream(filePath),
                headers: {
                  "content-type": contentTypeFor(assetName),
                  "content-length": stat.size,
                },
              });
            }

            core.info(`Uploaded ${files.length} metadata files to release ${releaseId}.`);

      - name: Update channel tag and release
        id: channel_release
        uses: actions/github-script@v7
        env:
          CHANNEL_TAG: ${{ needs.metadata.outputs.channel_release_tag }}
          TARGET_COMMIT_SHA: ${{ needs.metadata.outputs.commit_sha }}
          RELEASE_ENV: ${{ needs.metadata.outputs.release_env }}
          RELEASE_VERSION: ${{ needs.metadata.outputs.version }}
          RELEASE_TAG_NAME: ${{ needs.metadata.outputs.tag_name }}
        with:
          script: |
            const channelTag = process.env.CHANNEL_TAG;
            const targetSha = process.env.TARGET_COMMIT_SHA;
            const releaseEnv = process.env.RELEASE_ENV;
            const releaseVersion = process.env.RELEASE_VERSION;
            const releaseTagName = process.env.RELEASE_TAG_NAME;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const releaseName =
              releaseEnv === "dev" ? "Desktop Dev Channel" : "Desktop Prod Channel";
            const body = `Latest ${releaseEnv === "dev" ? "dev" : "prod"} manifest for version ${releaseVersion} (tag ${releaseTagName}).`;

            async function ensureTag() {
              try {
                await github.rest.git.updateRef({
                  owner,
                  repo,
                  ref: `tags/${channelTag}`,
                  sha: targetSha,
                  force: true,
                });
                core.info(`Updated tag '${channelTag}' to ${targetSha}.`);
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.git.createRef({
                    owner,
                    repo,
                    ref: `refs/tags/${channelTag}`,
                    sha: targetSha,
                  });
                  core.info(`Created tag '${channelTag}' at ${targetSha}.`);
                } else {
                  throw error;
                }
              }
            }

            async function upsertRelease() {
              try {
                const existing = await github.rest.repos.getReleaseByTag({
                  owner,
                  repo,
                  tag: channelTag,
                });
                const updated = await github.rest.repos.updateRelease({
                  owner,
                  repo,
                  release_id: existing.data.id,
                  tag_name: channelTag,
                  name: releaseName,
                  body,
                  draft: false,
                  prerelease: releaseEnv === "dev",
                });
                return updated.data;
              } catch (error) {
                if (error.status === 404) {
                  const created = await github.rest.repos.createRelease({
                    owner,
                    repo,
                    tag_name: channelTag,
                    target_commitish: targetSha,
                    name: releaseName,
                    body,
                    draft: false,
                    prerelease: releaseEnv === "dev",
                  });
                  return created.data;
                }
                throw error;
              }
            }

            await ensureTag();
            const release = await upsertRelease();
            core.setOutput("release_id", String(release.id));
            core.info(`Channel release ready at ${release.html_url}.`);

      - name: Upload channel manifest
        if: steps.channel_release.outputs.release_id != ''
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ steps.channel_release.outputs.release_id }}
          ASSET_ROOT: publish/latest
          NAME_STRATEGY: basename
        with:
          script: |
            const fs = require("node:fs");
            const path = require("node:path");

            const releaseId = Number(process.env.RELEASE_ID);
            const assetRoot = process.env.ASSET_ROOT;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            if (!assetRoot || !fs.existsSync(assetRoot)) {
              core.info(`Asset root '${assetRoot}' not found; skipping upload.`);
              return;
            }

            async function collectFiles(dir) {
              const entries = await fs.promises.readdir(dir, { withFileTypes: true });
              const files = [];
              for (const entry of entries) {
                const fullPath = path.join(dir, entry.name);
                if (entry.isDirectory()) {
                  files.push(...await collectFiles(fullPath));
                } else if (entry.isFile()) {
                  files.push(fullPath);
                }
              }
              return files;
            }

            const files = await collectFiles(assetRoot);
            if (files.length === 0) {
              core.info(`No files found under '${assetRoot}'.`);
              return;
            }

            const existingAssets = await github.paginate(
              github.rest.repos.listReleaseAssets,
              {
                owner,
                repo,
                release_id: releaseId,
                per_page: 100,
              },
            );
            const existingByName = new Map(
              existingAssets.map((asset) => [asset.name, asset.id]),
            );

            for (const filePath of files) {
              const assetName = path.basename(filePath);
              const stat = await fs.promises.stat(filePath);

              const existingId = existingByName.get(assetName);
              if (existingId) {
                core.info(`Deleting existing asset '${assetName}' (id ${existingId}).`);
                await github.rest.repos.deleteReleaseAsset({
                  owner,
                  repo,
                  asset_id: existingId,
                });
              }

              core.info(`Uploading '${assetName}' from ${filePath}.`);
              await github.rest.repos.uploadReleaseAsset({
                owner,
                repo,
                release_id: releaseId,
                name: assetName,
                data: fs.createReadStream(filePath),
                headers: {
                  "content-type": "application/json",
                  "content-length": stat.size,
                },
              });
            }

            core.info(`Uploaded ${files.length} channel manifest file(s) to release ${releaseId}.`);
