name: Release Desktop

on:
  push:
    branches:
      - main
    paths:
      - "apps/desktop/**"
      - "packages/**"
      - ".github/workflows/release-desktop.yml"
  workflow_dispatch:
    inputs:
      environment:
        description: "Release environment (prod promotes the most recent dev tag)"
        type: choice
        required: true
        default: prod
        options:
          - prod
          - dev
      version:
        description: "Semver version to promote (prod only, defaults to latest dev tag)"
        required: false
        type: string

jobs:
  metadata:
    name: Determine release metadata
    runs-on: ubuntu-latest
    permissions:
      contents: write
      models: read
    outputs:
      version: ${{ steps.meta.outputs.version }}
      tag_name: ${{ steps.meta.outputs.tag_name }}
      commit_sha: ${{ steps.meta.outputs.commit_sha }}
      release_env: ${{ steps.meta.outputs.release_env }}
      release_suffix: ${{ steps.meta.outputs.release_suffix }}
      release_flavor: ${{ steps.meta.outputs.release_flavor }}
      channel_release_tag: ${{ steps.meta.outputs.channel_release_tag }}
      version_path: ${{ steps.meta.outputs.version_path }}
      dev_tag_name: ${{ steps.meta.outputs.dev_tag_name }}
      release_notes: ${{ steps.release_notes.outputs.release-notes }}
      release_body: ${{ steps.release_body.outputs.release_body }}
    steps:
      - name: Checkout source
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute release metadata
        id: meta
        env:
          EVENT_NAME: ${{ github.event_name }}
          INPUT_ENVIRONMENT: ${{ github.event.inputs.environment || '' }}
          INPUT_VERSION: ${{ github.event.inputs.version || '' }}
        run: |
          set -euo pipefail
          git fetch --tags --force

          if [[ "${EVENT_NAME}" == "push" ]]; then
            RELEASE_ENV="dev"
          else
            case "${INPUT_ENVIRONMENT:-prod}" in
              dev|prod)
                RELEASE_ENV="${INPUT_ENVIRONMENT:-prod}"
                ;;
              *)
                echo "Unsupported environment '${INPUT_ENVIRONMENT}'" >&2
                exit 1
                ;;
            esac
          fi

          SEMVER_REGEX='^[0-9]+\.[0-9]+\.[0-9]+$'
          INPUT_VERSION="${INPUT_VERSION:-}"

          LAST_DEV_TAG="$(git tag --list 'desktop-dev-v*' --sort=-v:refname | head -n 1)"
          LAST_PROD_TAG="$(git tag --list 'desktop-v*' --sort=-v:refname | head -n 1)"

          if [[ "${RELEASE_ENV}" == "dev" ]]; then
            if [[ -n "${INPUT_VERSION}" ]]; then
              echo "Ignoring manual version '${INPUT_VERSION}' for dev release (automatic patch bump used)." >&2
            fi

            if [[ -z "${LAST_DEV_TAG}" ]]; then
              VERSION_BASE="0.0.0"
            else
              VERSION_BASE="${LAST_DEV_TAG#desktop-dev-v}"
            fi

            if [[ ! "${VERSION_BASE}" =~ ${SEMVER_REGEX} ]]; then
              echo "Last dev tag (${LAST_DEV_TAG:-none}) is not in x.y.z format." >&2
              exit 1
            fi

            IFS='.' read -r MAJOR MINOR PATCH <<< "${VERSION_BASE}"
            PATCH=$((PATCH + 1))
            VERSION="${MAJOR}.${MINOR}.${PATCH}"
            TAG_NAME="desktop-dev-v${VERSION}"
            COMMIT_SHA="${GITHUB_SHA}"
            DEV_TAG_NAME="${TAG_NAME}"
          else
            if [[ -n "${INPUT_VERSION}" ]]; then
              TARGET_VERSION="${INPUT_VERSION}"
              if [[ ! "${TARGET_VERSION}" =~ ${SEMVER_REGEX} ]]; then
                echo "Provided version '${TARGET_VERSION}' is not in x.y.z format." >&2
                exit 1
              fi
              TARGET_DEV_TAG="desktop-dev-v${TARGET_VERSION}"
              if ! git rev-parse -q --verify "refs/tags/${TARGET_DEV_TAG}" >/dev/null; then
                echo "Dev tag ${TARGET_DEV_TAG} not found for promotion." >&2
                exit 1
              fi
            else
              if [[ -z "${LAST_DEV_TAG}" ]]; then
                echo "No dev tag found to promote to prod." >&2
                exit 1
              fi
              TARGET_DEV_TAG="${LAST_DEV_TAG}"
              TARGET_VERSION="${TARGET_DEV_TAG#desktop-dev-v}"
              if [[ ! "${TARGET_VERSION}" =~ ${SEMVER_REGEX} ]]; then
                echo "Dev tag ${TARGET_DEV_TAG} is not in x.y.z format." >&2
                exit 1
              fi
            fi

            VERSION="${TARGET_VERSION}"
            TAG_NAME="desktop-v${VERSION}"
            COMMIT_SHA="$(git rev-parse "${TARGET_DEV_TAG}^{commit}")"
            DEV_TAG_NAME="${TARGET_DEV_TAG}"
          fi

          if git rev-parse -q --verify "refs/tags/${TAG_NAME}" >/dev/null; then
            echo "Tag ${TAG_NAME} already exists. Aborting." >&2
            exit 1
          fi

          VERSION_PATH="desktop/${RELEASE_ENV}/${VERSION}"
          if [[ "${RELEASE_ENV}" == "dev" ]]; then
            PREVIOUS_TAG="${LAST_DEV_TAG}"
          else
            PREVIOUS_TAG="${LAST_PROD_TAG}"
          fi
          RELEASE_NOTES_FROM_REF=""
          if [[ -n "${PREVIOUS_TAG}" ]]; then
            RELEASE_NOTES_FROM_REF="${PREVIOUS_TAG}"
            FIRST_AFTER_PREVIOUS="$(git rev-list --ancestry-path --reverse "${PREVIOUS_TAG}..${COMMIT_SHA}" | head -n 1)"
            if [[ -n "${FIRST_AFTER_PREVIOUS}" ]]; then
              RELEASE_NOTES_FROM="${FIRST_AFTER_PREVIOUS}"
            else
              RELEASE_NOTES_FROM="${COMMIT_SHA}"
            fi
          else
            RELEASE_NOTES_FROM="$(git rev-list --max-parents=0 "${COMMIT_SHA}" | tail -n 1)"
          fi
          RELEASE_NOTES_TO="${COMMIT_SHA}"

          if [[ "${RELEASE_ENV}" == "dev" ]]; then
            CHANNEL_RELEASE_TAG="desktop-dev"
            RELEASE_FLAVOR="dev"
            RELEASE_SUFFIX="-dev"
          else
            CHANNEL_RELEASE_TAG="desktop-prod"
            RELEASE_FLAVOR="prod"
            RELEASE_SUFFIX=""
          fi

          {
            echo "release_env=${RELEASE_ENV}"
            echo "release_suffix=${RELEASE_SUFFIX}"
            echo "version=${VERSION}"
            echo "tag_name=${TAG_NAME}"
            echo "commit_sha=${COMMIT_SHA}"
            echo "dev_tag_name=${DEV_TAG_NAME}"
            echo "version_path=${VERSION_PATH}"
            echo "channel_release_tag=${CHANNEL_RELEASE_TAG}"
            echo "release_flavor=${RELEASE_FLAVOR}"
            echo "release_notes_from=${RELEASE_NOTES_FROM}"
            echo "release_notes_to=${RELEASE_NOTES_TO}"
            echo "release_notes_from_ref=${RELEASE_NOTES_FROM_REF}"
          } >> "$GITHUB_OUTPUT"

      - name: Generate release notes
        id: release_notes
        uses: josiahsrc/ai-release-notes-builder@v1
        env:
          GITHUB_TOKEN: ${{ github.token }}
        with:
          prompt: |
            Keep it short and high level, focusing on bug fixes and features. 
            Use a single list of bullet points. Use emojis here and there. No header, 
            just bullet points.
          from: ${{ steps.meta.outputs.release_notes_from }}
          to: ${{ steps.meta.outputs.release_notes_to }}

      - name: Compose release body
        id: release_body
        env:
          RELEASE_NOTES: ${{ steps.release_notes.outputs['release-notes'] }}
          RELEASE_ENV: ${{ steps.meta.outputs.release_env }}
          VERSION: ${{ steps.meta.outputs.version }}
        run: |
          set -euo pipefail
          default_body="Automated ${RELEASE_ENV} channel build for version ${VERSION}."
          notes="${RELEASE_NOTES}"
          if [[ -n "${notes}" ]]; then
            body="${notes}"
          else
            body="${default_body}"
          fi
          printf 'release_body<<EOF\n%s\nEOF\n' "$body" >> "$GITHUB_OUTPUT"

      - name: Create release tag
        uses: actions/github-script@v7
        env:
          TAG_NAME: ${{ steps.meta.outputs.tag_name }}
          TARGET_SHA: ${{ steps.meta.outputs.commit_sha }}
        with:
          script: |
            const tagName = process.env.TAG_NAME;
            const targetSha = process.env.TARGET_SHA;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            core.info(`Creating tag ${tagName} at ${targetSha}`);

            await github.rest.git.createRef({
              owner,
              repo,
              ref: `refs/tags/${tagName}`,
              sha: targetSha,
            });

  build:
    name: Build ${{ matrix.label }}
    needs: metadata
    runs-on: ${{ matrix.os }}
    timeout-minutes: 60
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - label: macOS (universal)
            os: macos-14
            args: "--target universal-apple-darwin"
            rust_targets: "aarch64-apple-darwin,x86_64-apple-darwin"
            tauri_platform: macos
            node_platform: darwin
            artifact_name: desktop-macos
          - label: Linux
            os: ubuntu-22.04
            rust_targets: ""
            tauri_platform: linux
            node_platform: linux
            artifact_name: desktop-linux
            args: "--features linux-gpu"
          - label: Windows
            os: windows-latest
            args: "--features windows-gpu"
            rust_targets: ""
            tauri_platform: windows
            node_platform: win32
            artifact_name: desktop-windows
    env:
      RELEASE_VERSION: ${{ needs.metadata.outputs.version }}
      RELEASE_ENV: ${{ needs.metadata.outputs.release_env }}
      RELEASE_SUFFIX: ${{ needs.metadata.outputs.release_suffix }}
      RELEASE_FLAVOR: ${{ needs.metadata.outputs.release_flavor }}
      FLAVOR: ${{ needs.metadata.outputs.release_flavor }}
      VOQUILL_BUILD_FLAVOR: ${{ needs.metadata.outputs.release_flavor }}
      VOQUILL_DESKTOP_FLAVOR: ${{ needs.metadata.outputs.release_flavor }}
      TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
      TAURI_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_PRIVATE_KEY_PASSWORD }}
      TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
      TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_PRIVATE_KEY_PASSWORD }}
      TAURI_UPDATER_PUBLIC_KEY: ${{ secrets.TAURI_UPDATER_PUBLIC_KEY }}
      APPLE_API_KEY_BASE64: ${{ secrets.APPLE_API_KEY_BASE64 }}
      APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
      APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.metadata.outputs.commit_sha }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc
          cache: npm
          cache-dependency-path: package-lock.json

      - name: Sync Tauri release configuration
        run: node scripts/ci/set-tauri-release-config.mjs

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.rust_targets }}

      - name: Cache cargo
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            apps/desktop/src-tauri -> target

      - name: Set Windows-only build environment
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          # Shorten build and install paths for whisper + Vulkan
          echo "CARGO_TARGET_DIR=D:\cargo" >> $env:GITHUB_ENV
          echo "WHISPER_CMAKE_ARGS=-DGGML_VULKAN=ON -DCMAKE_INSTALL_PREFIX=C:/w" >> $env:GITHUB_ENV

      - name: Install system dependencies (Linux)
        if: matrix.os == 'ubuntu-22.04'
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update

          # Choose the right WebKitGTK dev package for the runner.
          if apt-cache show libwebkit2gtk-4.1-dev >/dev/null 2>&1; then
            WEBKIT_PKG=libwebkit2gtk-4.1-dev
          else
            WEBKIT_PKG=libwebkit2gtk-4.0-dev
          fi

          sudo apt-get install -y \
            build-essential pkg-config cmake \
            libgtk-3-dev "$WEBKIT_PKG" \
            libayatana-appindicator3-dev librsvg2-dev libasound2-dev libxdo-dev patchelf \
            libvulkan1 libvulkan-dev vulkan-tools

          # Install glslc from LunarG Vulkan SDK
          wget -qO - https://packages.lunarg.com/lunarg-signing-key-pub.asc | sudo apt-key add -
          sudo wget -qO /etc/apt/sources.list.d/lunarg-vulkan-jammy.list https://packages.lunarg.com/vulkan/lunarg-vulkan-jammy.list
          sudo apt-get update
          sudo apt-get install -y vulkan-sdk

      - name: Install dependencies
        run: npm ci

      - name: Configure Firebase client environment
        shell: bash
        env:
          RELEASE_FLAVOR: ${{ env.RELEASE_FLAVOR }}
        run: |
          set -euo pipefail

          if [[ "${RELEASE_FLAVOR}" == "prod" ]]; then
            api_key="AIzaSyDlPI-o5piDSNIG39EvJZJEz0gXCGEGk-w"
            auth_domain="voquill-prod.firebaseapp.com"
            project_id="voquill-prod"
            storage_bucket="voquill-prod.firebasestorage.app"
            messaging_sender_id="777461284594"
            app_id="1:777461284594:web:d431c9557d3e02395e5a6b"
            measurement_id="G-LKHEH0DPND"
          else
            api_key="AIzaSyCJ8C3ZW2bHjerneg5i0fr-b5uwuy7uULM"
            auth_domain="voquill-dev.firebaseapp.com"
            project_id="voquill-dev"
            storage_bucket="voquill-dev.firebasestorage.app"
            messaging_sender_id="778214168359"
            app_id="1:778214168359:web:66ee2ce5df76c8c2d77b02"
            measurement_id="G-V6Y1RSFBQX"
          fi

          {
            echo "VITE_FIREBASE_API_KEY=${api_key}"
            echo "VITE_FIREBASE_AUTH_DOMAIN=${auth_domain}"
            echo "VITE_FIREBASE_PROJECT_ID=${project_id}"
            echo "VITE_FIREBASE_STORAGE_BUCKET=${storage_bucket}"
            echo "VITE_FIREBASE_MESSAGING_SENDER_ID=${messaging_sender_id}"
            echo "VITE_FIREBASE_APP_ID=${app_id}"
            echo "VITE_FIREBASE_MEASUREMENT_ID=${measurement_id}"
            echo "VITE_USE_EMULATORS=false"
            echo "VITE_FLAVOR=${RELEASE_FLAVOR}"
          } >> "$GITHUB_ENV"

      - name: Install Vulkan SDK (Windows)
        if: matrix.os == 'windows-latest'
        uses: jakoch/install-vulkan-sdk-action@v1
        with:
          version: "1.3.290.0"        
          cache: true                 
          runtime: true               

      - name: Install GPU build deps (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          # 1) LLVM / Clang (for bindgen / whisper-rs-sys)
          choco install -y llvm
          choco install -y cmake --installargs 'ADD_CMAKE_TO_PATH=System' --no-progress

          # 2) Wire up clang
          "LIBCLANG_PATH=C:\Program Files\LLVM\bin"         >> $env:GITHUB_ENV
          "CLANG_PATH=C:\Program Files\LLVM\bin\clang.exe"  >> $env:GITHUB_ENV
          "C:\Program Files\LLVM\bin"                       >> $env:GITHUB_PATH

      - name: Import Apple signing certificate
        if: matrix.os == 'macos-14'
        id: import-macos-cert
        uses: apple-actions/import-codesign-certs@v2
        with:
          create-keychain: true
          keychain: build
          keychain-password: ${{ secrets.KEYCHAIN_PASSWORD }}
          keychain-timeout: 3600
          set-default-keychain: true
          p12-file-base64: ${{ secrets.APPLE_CERTIFICATE }}
          p12-password: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}

      - name: Allow codesign access to private keys (CI keychain)
        if: matrix.os == 'macos-14'
        run: |
          security set-key-partition-list -S apple-tool:,apple: -s -k "${{ secrets.KEYCHAIN_PASSWORD }}" build.keychain-db

      - name: Assert Developer ID Application identity is present
        if: matrix.os == 'macos-14'
        run: |
          set -euo pipefail
          out="$(security find-identity -v -p codesigning)"
          echo "$out"
          echo "$out" | grep -q "Developer ID Application" || {
            echo "No 'Developer ID Application' identity found. Import a .p12 exported with its private key." >&2
            exit 1
          }

      - name: Prepare Apple notary API key
        if: matrix.os == 'macos-14'
        run: |
          set -euo pipefail
          echo "$APPLE_API_KEY_BASE64" | base64 -d > AuthKey.p8
          ls -l AuthKey.p8
        shell: bash

      - name: Verify Apple signing identity
        if: matrix.os == 'macos-14'
        run: |
          set -euo pipefail
          keychain_path="${{ steps.import-macos-cert.outputs['keychain-path'] }}"
          if [[ -z "${keychain_path}" ]]; then
            keychain_path="${HOME}/Library/Keychains/build.keychain-db"
            echo "apple-actions/import-codesign-certs did not report a keychain path; falling back to ${keychain_path}." >&2
          fi
          output="$(security find-identity -v -p codesigning "${keychain_path}" || true)"
          printf '%s\n' "$output"
          summary_count="$(printf '%s\n' "$output" | awk '/valid identities found$/ { print $1; exit }')"
          if [[ -z "${summary_count}" || ! "${summary_count}" =~ ^[0-9]+$ ]]; then
            summary_count="$(printf '%s\n' "$output" | awk '/^[[:space:]]*[0-9]+\)/ { count++ } END { print count+0 }')"
          fi
          if [[ "${summary_count:-0}" -eq 0 ]]; then
            echo "No valid code signing identities were imported into ${keychain_path}." >&2
            echo "Ensure APPLE_CERTIFICATE contains a base64-encoded .p12 export that includes the private key." >&2
            exit 1
          fi

      - name: Notary connectivity probe
        if: matrix.os == 'macos-14'
        run: |
          xcrun notarytool history \
            --key "${GITHUB_WORKSPACE}/AuthKey.p8" \
            --key-id "${APPLE_API_KEY_ID}" \
            --issuer "${APPLE_API_ISSUER}"

      - name: Compute Tauri CLI args
        id: tauri-cli-args
        shell: bash
        env:
          MATRIX_ARGS: ${{ matrix.args }}
          RELEASE_ENV: ${{ needs.metadata.outputs.release_env }}
        run: |
          set -euo pipefail
          config_file="src-tauri/tauri.dev.conf.json"
          if [[ "${RELEASE_ENV}" == "prod" ]]; then
            config_file="src-tauri/tauri.prod.conf.json"
          fi
          config_flag="--config ${config_file}"
          matrix_args="${MATRIX_ARGS}"
          if [[ -z "${matrix_args}" ]]; then
            combined_args="${config_flag}"
          elif [[ "${matrix_args}" == *" -- "* ]]; then
            before="${matrix_args%% -- *}"
            after="${matrix_args#* -- }"
            if [[ -n "${before}" ]]; then
              combined_args="${before} ${config_flag} -- ${after}"
            else
              combined_args="${config_flag} -- ${after}"
            fi
          else
            combined_args="${matrix_args} ${config_flag}"
          fi
          printf 'Using %s for %s release.\n' "${config_file}" "${RELEASE_ENV}"
          echo "args=${combined_args}" >> "$GITHUB_OUTPUT"
          echo "config=${config_file}" >> "$GITHUB_OUTPUT"

      - name: Turbo build desktop workspace
        env:
          MACOSX_DEPLOYMENT_TARGET: "13.3"
          CMAKE_OSX_DEPLOYMENT_TARGET: "13.3"
          TAURI_PLATFORM: ${{ matrix.tauri_platform }}
          VOQUILL_DESKTOP_PLATFORM: ${{ matrix.node_platform }}
        run: npm run build -- --filter=desktop...

      - name: Build and publish
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_PLATFORM: ${{ matrix.tauri_platform }}
          VOQUILL_DESKTOP_PLATFORM: ${{ matrix.node_platform }}
          MACOSX_DEPLOYMENT_TARGET: "13.3"
          CMAKE_OSX_DEPLOYMENT_TARGET: "13.3"
          APPLE_TEAM_ID: ${{ env.APPLE_TEAM_ID }}
          APPLE_SIGNING_IDENTITY: ${{ env.APPLE_SIGNING_IDENTITY }}
          APPLE_API_KEY: ${{ env.APPLE_API_KEY_ID }}
          APPLE_API_KEY_PATH: ${{ github.workspace }}/AuthKey.p8
          APPLE_API_ISSUER: ${{ env.APPLE_API_ISSUER }}
          TAURI_LOG_LEVEL: ${{ env.TAURI_LOG_LEVEL }}
          RUST_LOG: ${{ env.RUST_LOG }}
        with:
          projectPath: apps/desktop
          tauriScript: npm run --workspace desktop tauri
          args: ${{ steps.tauri-cli-args.outputs.args }}
          tagName: ${{ needs.metadata.outputs.tag_name }}
          releaseName: desktop${{ needs.metadata.outputs.release_suffix }} v${{ needs.metadata.outputs.version }}
          releaseBody: ${{ needs.metadata.outputs.release_body }}
          releaseDraft: false
          prerelease: ${{ needs.metadata.outputs.release_env != 'prod' }}
          includeUpdaterJson: true

  update-channel:
    name: Update channel release asset
    needs: [metadata, build]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      CHANNEL_TAG: ${{ needs.metadata.outputs.channel_release_tag }}
      GH_REPO: ${{ github.repository }}
      RELEASE_TAG: ${{ needs.metadata.outputs.tag_name }}
    steps:
      - name: Download latest.json from release
        run: |
          set -euo pipefail
          mkdir -p dist
          gh release download "$RELEASE_TAG" --pattern "latest.json" --dir dist --clobber
          if [[ ! -s dist/latest.json ]]; then
            echo "latest.json was not downloaded from release ${RELEASE_TAG}" >&2
            ls -la dist
            exit 1
          fi
      - name: Validate downloaded latest.json
        run: |
          set -euo pipefail
          version="$(jq -r '.version // empty' dist/latest.json)"
          expected="${{ needs.metadata.outputs.version }}"
          if [[ -z "${version}" ]]; then
            echo "latest.json is missing a 'version' field." >&2
            exit 1
          fi
          if [[ "${version}" != "${expected}" ]]; then
            echo "latest.json version '${version}' does not match expected '${expected}'." >&2
            exit 1
          fi
      - name: Upload to channel
        run: |
          set -euo pipefail
          gh release upload "$CHANNEL_TAG" dist/latest.json --clobber
